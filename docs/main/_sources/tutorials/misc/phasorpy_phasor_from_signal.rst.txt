
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/misc/phasorpy_phasor_from_signal.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: xml

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_misc_phasorpy_phasor_from_signal.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_misc_phasorpy_phasor_from_signal.py:


Benchmark phasor_from_signal
============================

Benchmark the ``phasor_from_signal`` function.

The :py:func:`phasorpy.phasor.phasor_from_signal` function used to calculate
phasor coordinates from time-resolved or spectral signals can operate in
two modes:

- using an internal Cython function optimized for calculating a small number
  of harmonics, optionally using multiple threads.

- using a real forward Fast Fourier Transform (FFT), ``numpy.fft.rfft`` or
  a drop-in replacement function like ``scipy.fft.rfft``
  or ``mkl_fft.interfaces.numpy_fft.rfft``.

This tutorial compares the performance of the two modes.

Import required modules and functions:

.. GENERATED FROM PYTHON SOURCE LINES 23-44

.. code-block:: Python


    from timeit import timeit

    import numpy
    from numpy.fft import rfft as numpy_fft  # noqa: F401

    from phasorpy.phasor import phasor_from_signal  # noqa: F401
    from phasorpy.utils import number_threads

    try:
        from scipy.fft import rfft as scipy_fft
    except ImportError:
        scipy_fft = None

    try:
        from mkl_fft.interfaces.numpy_fft import rfft as mkl_fft
    except ImportError:
        mkl_fft = None

    rng = numpy.random.default_rng(42)  # initialize random number generator








.. GENERATED FROM PYTHON SOURCE LINES 45-49

Run benchmark
-------------

Create a random signal with a size and dtype similar to real-world data:

.. GENERATED FROM PYTHON SOURCE LINES 49-56

.. code-block:: Python


    signal = rng.random((384, 384, 384))
    signal += 1.1
    signal *= 3723  # ~12 bit
    signal = signal.astype(numpy.uint16)  # 108 MB
    signal[signal < 0.05] = 0.0  # 5% no signal








.. GENERATED FROM PYTHON SOURCE LINES 57-59

Print execution times depending on FFT function, axis, number of harmonics,
and number of threads:

.. GENERATED FROM PYTHON SOURCE LINES 59-95

.. code-block:: Python


    statement = """
    phasor_from_signal(signal, axis=axis, harmonic=harmonic, **kwargs)
    """
    number = 1  # how many times to execute statement
    ref = None  # reference duration


    def print_(descr, t):
        print(f'    {descr:20s}{t / number:>6.3f}s {t / ref:>6.2f}')


    for harmonic in ([1], [1, 2, 3, 4, 5, 6, 7, 8]):
        print(f'harmonics {len(harmonic)}')
        for axis in (-1, 0, 2):
            print(f'  axis {axis}')
            kwargs = {'use_fft': False, 'num_threads': 1}
            t = timeit(statement, number=number, globals=globals())
            if ref is None:
                ref = t
            print_('not_fft', t)

            num_threads = number_threads(0, 6)
            if num_threads > 1:
                kwargs = {'use_fft': False, 'num_threads': num_threads}
                t = timeit(statement, number=number, globals=globals())
                print_(f'not_fft ({num_threads} threads)', t)

            for fft_name in ('numpy_fft', 'scipy_fft', 'mkl_fft'):
                fft_func = globals()[fft_name]
                if fft_func is None:
                    continue
                kwargs = {'use_fft': True, 'rfft': fft_func}
                t = timeit(statement, number=number, globals=globals())
                print_(f'{fft_name}', t)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    harmonics 1
      axis -1
        not_fft              0.059s   1.00
        not_fft (2 threads)  0.029s   0.49
        numpy_fft            0.216s   3.69
        scipy_fft            0.224s   3.83
        mkl_fft              0.150s   2.56
      axis 0
        not_fft              0.168s   2.87
        not_fft (2 threads)  0.083s   1.42
        numpy_fft            0.451s   7.70
        scipy_fft            0.337s   5.76
        mkl_fft              0.249s   4.25
      axis 2
        not_fft              0.057s   0.98
        not_fft (2 threads)  0.048s   0.81
        numpy_fft            0.214s   3.66
        scipy_fft            0.223s   3.81
        mkl_fft              0.148s   2.53
    harmonics 8
      axis -1
        not_fft              0.460s   7.85
        not_fft (2 threads)  0.228s   3.90
        numpy_fft            0.226s   3.85
        scipy_fft            0.233s   3.97
        mkl_fft              0.159s   2.71
      axis 0
        not_fft              1.337s  22.83
        not_fft (2 threads)  0.685s  11.69
        numpy_fft            0.456s   7.78
        scipy_fft            0.342s   5.85
        mkl_fft              0.254s   4.34
      axis 2
        not_fft              0.454s   7.76
        not_fft (2 threads)  0.229s   3.91
        numpy_fft            0.222s   3.80
        scipy_fft            0.233s   3.98
        mkl_fft              0.158s   2.70




.. GENERATED FROM PYTHON SOURCE LINES 96-137

For reference, the results on a Core i7-14700K CPU, Windows 11,
Python 3.14.0, numpy 2.3.5, scipy 1.16.3, mkl_fft 2.1.1::

    harmonics 1
      axis -1
        not_fft              0.034s   1.00
        not_fft (6 threads)  0.006s   0.17
        numpy_fft            0.274s   8.03
        scipy_fft            0.240s   7.04
        mkl_fft              0.141s   4.14
      axis 0
        not_fft              0.162s   4.75
        not_fft (6 threads)  0.038s   1.13
        numpy_fft            0.697s  20.44
        scipy_fft            0.496s  14.54
        mkl_fft              0.167s   4.90
      axis 2
        not_fft              0.038s   1.12
        not_fft (6 threads)  0.006s   0.16
        numpy_fft            0.272s   7.99
        scipy_fft            0.240s   7.04
        mkl_fft              0.130s   3.83
    harmonics 8
      axis -1
        not_fft              0.287s   8.43
        not_fft (6 threads)  0.040s   1.17
        numpy_fft            0.288s   8.45
        scipy_fft            0.253s   7.43
        mkl_fft              0.161s   4.74
      axis 0
        not_fft              1.161s  34.04
        not_fft (6 threads)  0.425s  12.47
        numpy_fft            0.715s  20.97
        scipy_fft            0.541s  15.88
        mkl_fft              0.183s   5.38
      axis 2
        not_fft              0.282s   8.27
        not_fft (6 threads)  0.038s   1.13
        numpy_fft            0.288s   8.46
        scipy_fft            0.255s   7.49
        mkl_fft              0.155s   4.56

.. GENERATED FROM PYTHON SOURCE LINES 139-154

Results
-------

- Using the Cython implementation is significantly faster than using the
  ``numpy.fft``-based implementation for single harmonics.
- Using multiple threads can significantly speed up the Cython mode.
- The FFT functions from ``scipy`` and ``mkl_fft`` outperform the
  ``numpy.fft`` function. Specifically, ``mkl_fft`` is very performant.
- Using FFT becomes more competitive when calculating a larger number of
  harmonics.
- Computing over the last axis is significantly faster compared to the first
  axis. That is because the samples in the last dimension are contiguous in
  memory.

Note that these results were obtained on a single dataset of random numbers.

.. GENERATED FROM PYTHON SOURCE LINES 156-162

Conclusions
-----------

Using the Cython implementation is a reasonable default when calculating
a few harmonics. Using FFT is a better choice when computing a large number
of harmonics, especially with an optimized FFT function.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 8.662 seconds)


.. _sphx_glr_download_tutorials_misc_phasorpy_phasor_from_signal.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: phasorpy_phasor_from_signal.ipynb <phasorpy_phasor_from_signal.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: phasorpy_phasor_from_signal.py <phasorpy_phasor_from_signal.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: phasorpy_phasor_from_signal.zip <phasorpy_phasor_from_signal.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_


.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/api/phasorpy_lifetime_to_signal.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: xml

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_api_phasorpy_lifetime_to_signal.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_api_phasorpy_lifetime_to_signal.py:


Synthesize signals from lifetimes
=================================

An introduction to the `lifetime_to_signal` function.

The :py:func:`phasorpy.lifetime.lifetime_to_signal` function is used
to synthesize time- and frequency-domain signals as a function of
fundamental frequency, single or multiple lifetime components,
lifetime fractions, mean and background intensity, and instrument
response function (IRF) peak location and width.

.. GENERATED FROM PYTHON SOURCE LINES 16-17

Import required modules and functions:

.. GENERATED FROM PYTHON SOURCE LINES 17-28

.. code-block:: Python


    import numpy
    from matplotlib import pyplot

    from phasorpy.lifetime import (
        lifetime_to_signal,
        phasor_calibrate,
        phasor_from_lifetime,
    )
    from phasorpy.phasor import phasor_from_signal








.. GENERATED FROM PYTHON SOURCE LINES 29-30

Define common parameters used throughout the tutorial:

.. GENERATED FROM PYTHON SOURCE LINES 30-45

.. code-block:: Python


    frequency = 80.0  # fundamental frequency in MHz
    reference_lifetime = 4.2  # lifetime of reference signal in ns

    lifetimes = [0.5, 1.0, 2.0, 4.0]  # lifetimes in ns
    fractions = [0.25, 0.25, 0.25, 0.25]  # fractional intensities

    settings = {
        'samples': 256,  # number of samples to synthesize
        'mean': 1.0,  # average intensity
        'background': 0.0,  # no signal from background
        'zero_phase': None,  # location of IRF peak in the phase
        'zero_stdev': None,  # standard deviation of IRF in radians
    }








.. GENERATED FROM PYTHON SOURCE LINES 46-51

Time domain, multi exponential
------------------------------

Synthesize a time-domain signal of a multi-component lifetime system with
given fractional intensities, convolved with an instrument response function:

.. GENERATED FROM PYTHON SOURCE LINES 51-56

.. code-block:: Python


    signal, instrument_response, times = lifetime_to_signal(
        frequency, lifetimes, fractions, **settings
    )








.. GENERATED FROM PYTHON SOURCE LINES 57-62

A reference signal of known lifetime is required to calibrate the phasor
coordinates. The reference signal must be obtained with the same instrument
and sampling parameters.
The calibrated phasor coordinates match the theoretical phasor coordinates
expected for the lifetimes:

.. GENERATED FROM PYTHON SOURCE LINES 62-85

.. code-block:: Python


    reference_signal, _, _ = lifetime_to_signal(
        frequency, reference_lifetime, **settings
    )


    def verify_signal(fractions):
        """Verify calibrated phasor coordinates match expected results."""
        assert numpy.allclose(
            phasor_calibrate(
                *phasor_from_signal(signal)[1:],
                *phasor_from_signal(reference_signal),
                frequency,
                reference_lifetime,
            ),
            phasor_from_lifetime(frequency, lifetimes, fractions),
            atol=1e-3,
            equal_nan=True,
        )


    verify_signal(fractions)








.. GENERATED FROM PYTHON SOURCE LINES 86-88

Plot the synthesized signals (multi-exponential, reference, and
instrument response):

.. GENERATED FROM PYTHON SOURCE LINES 88-101

.. code-block:: Python


    fig, ax = pyplot.subplots()
    ax.set(
        title=f'Time-domain signals ({frequency} MHz)',
        xlabel='Times [ns]',
        ylabel='Intensity [au]',
    )
    ax.plot(times, signal, label='Multi-exponential')
    ax.plot(times, reference_signal, label='Reference')
    ax.plot(times, instrument_response, label='Instrument response')
    ax.legend()
    pyplot.show()




.. image-sg:: /tutorials/api/images/sphx_glr_phasorpy_lifetime_to_signal_001.png
   :alt: Time-domain signals (80.0 MHz)
   :srcset: /tutorials/api/images/sphx_glr_phasorpy_lifetime_to_signal_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 102-107

Time domain, single exponential
-------------------------------

To synthesize separate signals for each lifetime component at once,
omit the lifetime fractions:

.. GENERATED FROM PYTHON SOURCE LINES 107-112

.. code-block:: Python


    signal, _, times = lifetime_to_signal(frequency, lifetimes, **settings)

    verify_signal(None)








.. GENERATED FROM PYTHON SOURCE LINES 113-114

Plot the synthesized signals:

.. GENERATED FROM PYTHON SOURCE LINES 114-125

.. code-block:: Python


    fig, ax = pyplot.subplots()
    ax.set(
        title=f'Time-domain signals ({frequency} MHz)',
        xlabel='Times [ns]',
        ylabel='Intensity [au]',
    )
    ax.plot(times, signal.T, label=[f'{t} ns' for t in lifetimes])
    ax.legend()
    pyplot.show()




.. image-sg:: /tutorials/api/images/sphx_glr_phasorpy_lifetime_to_signal_002.png
   :alt: Time-domain signals (80.0 MHz)
   :srcset: /tutorials/api/images/sphx_glr_phasorpy_lifetime_to_signal_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 126-127

As expected, the shorter the lifetime, the faster the decay.

.. GENERATED FROM PYTHON SOURCE LINES 129-134

Frequency domain, multi exponential
-----------------------------------

To synthesize a frequency-domain homodyne signal, limit the
synthesis to the fundamental frequency (``harmonic=1``):

.. GENERATED FROM PYTHON SOURCE LINES 134-145

.. code-block:: Python


    signal, instrument_response, _ = lifetime_to_signal(
        frequency, lifetimes, fractions, harmonic=1, **settings
    )

    reference_signal, _, _ = lifetime_to_signal(
        frequency, reference_lifetime, harmonic=1, **settings
    )

    verify_signal(fractions)








.. GENERATED FROM PYTHON SOURCE LINES 146-147

Plot the synthesized signals:

.. GENERATED FROM PYTHON SOURCE LINES 147-163

.. code-block:: Python


    phase = numpy.linspace(0.0, 360.0, signal.size)

    fig, ax = pyplot.subplots()
    ax.set(
        title=f'Frequency-domain signals ({frequency} MHz)',
        xlabel='Phase [°]',
        ylabel='Intensity [au]',
        xticks=[0, 90, 180, 270, 360],
    )
    ax.plot(phase, signal, label='Multi-exponential')
    ax.plot(phase, reference_signal, label='Reference')
    ax.plot(phase, instrument_response, label='Instrument response')
    ax.legend()
    pyplot.show()




.. image-sg:: /tutorials/api/images/sphx_glr_phasorpy_lifetime_to_signal_003.png
   :alt: Frequency-domain signals (80.0 MHz)
   :srcset: /tutorials/api/images/sphx_glr_phasorpy_lifetime_to_signal_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 164-169

Frequency domain, single exponential
------------------------------------

To synthesize separate signals for each lifetime component at once,
omit the lifetime fractions:

.. GENERATED FROM PYTHON SOURCE LINES 169-174

.. code-block:: Python


    signal, _, _ = lifetime_to_signal(frequency, lifetimes, harmonic=1, **settings)

    verify_signal(None)








.. GENERATED FROM PYTHON SOURCE LINES 175-176

Plot the synthesized signals:

.. GENERATED FROM PYTHON SOURCE LINES 176-188

.. code-block:: Python


    fig, ax = pyplot.subplots()
    ax.set(
        title=f'Frequency-domain signals ({frequency} MHz)',
        xlabel='Phase [°]',
        ylabel='Intensity [au]',
        xticks=[0, 90, 180, 270, 360],
    )
    ax.plot(phase, signal.T, label=[f'{t} ns' for t in lifetimes])
    ax.legend()
    pyplot.show()




.. image-sg:: /tutorials/api/images/sphx_glr_phasorpy_lifetime_to_signal_004.png
   :alt: Frequency-domain signals (80.0 MHz)
   :srcset: /tutorials/api/images/sphx_glr_phasorpy_lifetime_to_signal_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 189-191

As expected, the shorter the lifetime, the smaller the phase shift and
demodulation.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.308 seconds)


.. _sphx_glr_download_tutorials_api_phasorpy_lifetime_to_signal.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: phasorpy_lifetime_to_signal.ipynb <phasorpy_lifetime_to_signal.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: phasorpy_lifetime_to_signal.py <phasorpy_lifetime_to_signal.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: phasorpy_lifetime_to_signal.zip <phasorpy_lifetime_to_signal.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
